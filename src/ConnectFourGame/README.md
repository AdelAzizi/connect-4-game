# مستندات کلاس `ConnectFourGame`

این مستند به تشریح کامل کلاس `ConnectFourGame`، که به عنوان کلاس اصلی و هماهنگ‌کننده کل بازی عمل می‌کند، می‌پردازد.

## 📝 نمای کلی

کلاس `ConnectFourGame` مغز متفکر برنامه است. این کلاس مسئولیت‌های زیر را بر عهده دارد:
-   ایجاد و مدیریت پنجره اصلی بازی.
-   اجرای حلقه اصلی بازی (Game Loop) که شامل پردازش رویدادها، به‌روزرسانی منطق و رندر کردن گرافیک است.
-   مدیریت وضعیت کلی بازی (مانند منوی اصلی، تنظیمات بازیکن، حین بازی و پایان بازی).
-   نگهداری نمونه‌هایی از کلاس‌های `GameBoard` و `Player`.
-   پیاده‌سازی منطق هوش مصنوعی برای حریف کامپیوتری.

## 📁 ساختار فایل

این کلاس در دو فایل زیر سازماندهی شده است:

-   `ConnectFourGame.h`: **فایل هدر** که ساختار و رابط عمومی کلاس را تعریف می‌کند.
-   `ConnectFourGame.cpp`: **فایل پیاده‌سازی** که تمام منطق و جزئیات متدهای کلاس را در بر می‌گیرد.

---

## 📄 تحلیل فایل هدر (`ConnectFourGame.h`)

فایل هدر `ConnectFourGame.h` نقشه کلی کلاس را ارائه می‌دهد و تمام متغیرها و توابع عضو آن را اعلان می‌کند.

```cpp
#pragma once

#include <SFML/Graphics.hpp>
#include <vector>
#include <string>
#include <utility> // For std::pair

#include "../Constants.h"
#include "../Player/Player.h"
#include "../GameBoard/GameBoard.h"

class ConnectFourGame {
public:
    ConnectFourGame();
    void run();

private:
    // --- Member Variables ---
    // ... (All member variables listed here) ...

    // --- Private Methods ---
    // ... (All private methods listed here) ...
};
```

### متغیرهای عضو کلیدی (`private` members):

-   **عناصر اصلی گرافیکی**:
    -   `sf::RenderWindow window`: پنجره اصلی برنامه که تمام محتوا روی آن رندر می‌شود.
    -   `sf::Font font`: فونت استفاده‌شده برای تمام متون در بازی.
-   **عناصر منطقی و وضعیت بازی**:
    -   `GameBoard board`: نمونه‌ای از کلاس `GameBoard` که وضعیت فعلی صفحه بازی را نگهداری می‌کند.
    -   `std::vector<Player> players`: یک وکتور برای ذخیره اشیاء دو بازیکن.
    -   `Player* currentPlayer`: یک اشاره‌گر که به بازیکنی که نوبت حرکت اوست، اشاره می‌کند.
    -   `GameState gameState`: یک متغیر از نوع `enum` که وضعیت فعلی بازی را مشخص می‌کند (مثلاً `MAIN_MENU`, `PLAYING`).

### متدهای کلیدی (`private` methods):

-   **حلقه اصلی بازی**:
    -   `run()`: متد عمومی که حلقه اصلی بازی را تا زمانی که پنجره باز است، اجرا می‌کند.
    -   `handleEvents()`: رویدادهای کاربر (مانند کلیک موس یا فشردن کلید) را پردازش می‌کند.
    -   `update()`: منطق بازی را به‌روزرسانی می‌کند (مثلاً حرکت هوش مصنوعی).
    -   `render()`: تمام عناصر گرافیکی را بر اساس وضعیت فعلی بازی روی صفحه ترسیم می‌کند.
-   **مدیریت هوش مصنوعی**:
    -   `findBestMove()`: بهترین حرکت ممکن برای کامپیوتر را با استفاده از یک استراتژی چندلایه پیدا می‌کند.
    -   `minimax(...)`: پیاده‌سازی الگوریتم Minimax با هرس آلفا-بتا برای جستجوی بهترین حرکت در درخت بازی.
    -   `evaluateBoard(...)`: یک تابع هیوریستیک که به یک وضعیت مشخص از صفحه بازی امتیاز می‌دهد تا `minimax` بتواند بین حرکات مختلف تصمیم‌گیری کند.

---

##  cpp. تحلیل فایل پیاده‌سازی (`ConnectFourGame.cpp`)

این فایل بسیار بزرگ است و منطق کامل بازی در آن قرار دارد. در ادامه، بخش‌های کلیدی آن را تحلیل می‌کنیم.

### حلقه اصلی بازی (`run` method)

```cpp
void ConnectFourGame::run() {
    while (window.isOpen()) {
        handleEvents();
        update();
        render();
    }
}
```
این ساختار، یک الگوی استاندارد در بازی‌سازی است. در هر فریم از بازی، برنامه به ترتیب رویدادها را پردازش، منطق را به‌روزرسانی و سپس صفحه را دوباره ترسیم می‌کند.

### مدیریت رویدادها (`handleEvents` method)

```cpp
void ConnectFourGame::handleEvents() {
    sf::Event event;
    while (window.pollEvent(event)) {
        // ... (code to close window) ...

        switch (gameState) {
            case MAIN_MENU:    handleMainMenu(event); break;
            case PLAYER_SETUP: handlePlayerSetup(event); break;
            case PLAYING:      handlePlaying(event); break;
            // ... (game over handling) ...
        }
    }
}
```
این تابع از یک `switch` بر روی `gameState` استفاده می‌کند تا رویدادها را به تابع مناسب ارسال کند. برای مثال، اگر بازی در منوی اصلی باشد، فقط `handleMainMenu` فراخوانی می‌شود و کلیک‌های موس در صفحه بازی نادیده گرفته می‌شوند. این کار به جداسازی منطق در وضعیت‌های مختلف کمک می‌کند.

### منطق هوش مصنوعی (`findBestMove`, `minimax`, `evaluateBoard`)

این بخش، پیچیده‌ترین قسمت برنامه است.

1.  **`findBestMove()`**: این تابع استراتژی هوش مصنوعی را تعیین می‌کند:
    a.  **حرکت برنده:** آیا کامپیوتر می‌تواند در این نوبت برنده شود؟ اگر بله، آن حرکت را انجام بده.
    b.  **مسدود کردن حریف:** آیا حریف در نوبت بعدی خود برنده می‌شود؟ اگر بله، جلوی او را بگیر.
    c.  **استفاده از `minimax`:** در غیر این صورت، از الگوریتم `minimax` برای یافتن بهترین حرکت استراتژیک استفاده کن.

2.  **`minimax(board, depth, alpha, beta, maximizingPlayer)`**:
    -   این یک تابع بازگشتی است که درخت تصمیمات بازی را تا عمق `MAX_DEPTH` جستجو می‌کند.
    -   `maximizingPlayer` مشخص می‌کند که آیا نوبت کامپیوتر است (که می‌خواهد امتیاز را بیشینه کند) یا نوبت بازیکن (که می‌خواهد امتیاز را کمینه کند).
    -   **هرس آلفا-بتا (`alpha-beta pruning`)**: `alpha` و `beta` دو متغیر هستند که برای بهینه‌سازی الگوریتم استفاده می‌شوند. اگر الگوریتم تشخیص دهد که یک شاخه از درخت بازی قطعاً به یک نتیجه بدتر از نتیجه‌ای که قبلاً پیدا شده منجر می‌شود، آن شاخه را به طور کامل نادیده می‌گیرد (`if (beta <= alpha) break;`). این بهینه‌سازی سرعت جستجو را به شدت افزایش می‌دهد.

3.  **`evaluateBoard(board)`**:
    -   این تابع قلب تصمیم‌گیری `minimax` است. به یک وضعیت از صفحه بازی یک امتیاز عددی اختصاص می‌دهد.
    -   امتیازدهی به این صورت است:
        -   برد کامپیوتر: امتیاز بسیار بالا (`+100000`).
        -   باخت کامپیوتر: امتیاز بسیار پایین (`-100000`).
        -   تعداد ردیف‌های سه‌تایی کامپیوتر: امتیاز مثبت (`+100`).
        -   تعداد ردیف‌های دوتایی کامپیوتر: امتیاز مثبت (`+10`).
        -   تعداد ردیف‌های سه‌تایی و دوتایی حریف: امتیاز منفی.
    -   `minimax` سعی می‌کند به وضعیتی برسد که این امتیاز را برای کامپیوتر به حداکثر برساند.
